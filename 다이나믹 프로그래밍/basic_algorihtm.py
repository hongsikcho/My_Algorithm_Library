# 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시킬 수 있는 알고리즘.
# 보통 다음의 조건을 만족할 때 사용한다.
# 1. 큰 문제를 작은 문제로 나눌 수 있다.
# 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
# 이를 만족한는 가장 대표적인 문제는 '피보나치 수열'이다. 

d = [0] * 100

def fibo(x):
  if x == 1 or x == 2:
    return 1
  
  if d[x] != 0:
    return d[x]
  
  d[x] = fibo(x - 1) + fibo(x - 2)
  return d[x]

print(fibo(99))

# 하지만 이 일고리즘에는 치명적인 문제가 있는데 바로 중복된 값이 계속 계산된다는 것이다. 따라서 수가 조금 커지면 시간복잡도가 굉장히 상승하게 된다.
# 이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 '탑다운 방식'이라고 말한다.(위의 알고리즘)
# 반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 '보텀업 방식'이라고 말한다.(바로 밑 알고리즘)

d = [0] * 100

d[1] = 1
d[2] = 2
n = 99

for i in range(3 , n + 1):
  d[i] = d[i - 1] + d[i - 2]
  
print(d[n])

# 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다. 보텀업 방식에서 사용되는 결과 저장용 리스트는'DP'테이블'이라고 부르면 메모이제이션은 탑다운 방식에 국한되어 사용되는
# 표현이다.

# 문제를 푸는 첫 번째 단계는 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이다. 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때
# 시간이 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 확인.
# 탑다운 방식보다는 보텀업 방식으로 풀이하는것을 추천
